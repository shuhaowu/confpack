from __future__ import print_function

import copy
import getpass
import os.path
import socket

try:
  from cStringIO import StringIO
except ImportError:
  from StringIO import StringIO

import yaml

BASE_CONTROL = {
  'section': 'config',
  'priority': 'optional',
  'architecture': 'all',
  'essential': 'no',
  'description': 'configuration package generated by confpack'
}

_user = getpass.getuser()
DEFAULT_MAINTAINER = "{} <{}@{}>".format(_user, _user, socket.gethostname())
del _user

REQUIRED_CONTROL_FIELD = (
  "package",
  "version",
  "architecture",
  "maintainer",
  "description",
  "section",
  "priority",
)

REQUIRED_CONTROL_FIELD_SET = set(REQUIRED_CONTROL_FIELD)


class InvalidControlFile(KeyError):
  pass


class ControlFile(object):
  @classmethod
  def from_package_directory(cls, path, config):
    custom_control = yaml.load(os.path.join(path, "__control", "control.yml"))
    custom_control["package"] = config.get("package_name_prefix", "") + os.path.basename(path)
    custom_control["maintainer"] = config.get("maintainer", DEFAULT_MAINTAINER)
    return cls(custom_control, config)

  def __init__(self, custom_control, config):
    self._control = copy.deepcopy(BASE_CONTROL)
    self._control.update(custom_control)
    self._config = config

  def _write_line(self, buf, key):
    try:
      values = self._control[key]
    except KeyError:
      raise InvalidControlFile("missing key '{}'".format(key))
    else:
      if isinstance(values, (tuple, list)):
        values = ", ".join(values)

      print("{}: {}".format(key.title(), values), file=buf)

  def __str__(self):
    buf = StringIO()
    for key in REQUIRED_CONTROL_FIELD:
      self._write_line(buf, key)

    for key in self._control:
      if key in REQUIRED_CONTROL_FIELD_SET:
        continue

      self._write_line(buf, key)

    return buf.getvalue()

  dumps = __str__
